/*Extended sound player class. Original class created by Ronny Welter Copyright (c) 2009  */package com.codezen.mse.playr{			import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.events.ProgressEvent;	import flash.events.TimerEvent;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundLoaderContext;	import flash.media.SoundTransform;	import flash.net.URLRequest;	import flash.utils.Timer;		/*	Todo list	---------	StreamPreload.COMPLETE > Get the Track length info from the ID3 tag.		*/	/**	 * Playr class by Ronny Welter. <br/>	 * Makes creating a music player easy.<br/>	 * Author: Ronny Welter <br/>	 * URL: http://Playr.noCreativity.com <br/>	 * Mail: senderHas[at]noCreativity.com <br/>	 * <br/>	 * The Playr class can be used to create easily a music player in your application/site using only a few lines of code. <br/>	 * Playr takes the heavy lifting off your hands, while you can just create cool things. Every type of application is possible starting from just playing a loop to the core of a full blown audio player.	 */	public class Playr extends EventDispatcher{					public var repeat:String = PlayrRepeat.REPEAT_NONE;		public var trackDirectory:String="";		public var scrobbled:Boolean = false;		private var singleTrack:Boolean = false;		private var _playrState:String = PlayrStates.INIT;																				private var _volume:Number=1;		private var _panning:Number=0;		private var _sound:Sound;		private var _soundChannel:SoundChannel;		private var _playlist:PlaylistManager;		private var _autoPlay:Boolean=false;		private var _pauseTimer:Number=0;		private var _trackProgressTimer:Timer = new Timer(250);		private var _mute:Boolean=false;		private var _playButton:DisplayObject;		private var _pauseButton:DisplayObject;		private var _stopButton:DisplayObject;		private var _nextButton:DisplayObject;		private var _prevButton:DisplayObject;		private var _muteButton:DisplayObject;		private var _togglePlayPauseButton:DisplayObject;		private var fadeTimer:Timer;		private var fadeBegin:Number;		private var fadeEnd:Number;		private var fadeTime:Number;		private var bufferSize:Number = 5000;		/********************************************************************************		*********************************************************************************		**********************									*************************		**********************									*************************		**********************			Public methods			*************************		**********************									*************************		**********************									*************************		*********************************************************************************		********************************************************************************/  							/**		 * Creates a Playr instance. You can actually build a complete playlistsupported music player using only the constructor. Just set the all of this at once, and you're set!		 */		public function Playr(playlistURL:String='',trackDirectory:String='',autoPlay:Boolean=false,shuffle:Boolean=false,repeat:String=PlayrRepeat.REPEAT_NONE){			fadeTimer = new Timer(100);			fadeTimer.addEventListener(TimerEvent.TIMER,handleUpdate);			this.trackDirectory=trackDirectory;			this.repeat = repeat;						_playlist = new PlaylistManager(playlistURL);			this.autoPlay = autoPlay;			this.shuffle = shuffle;						_playlist.addEventListener(PlayrInternalEvent.PLAYLIST_LOADED,playlistManagerReady);			_playlist.addEventListener(PlayrInternalEvent.PLAYLIST_TRACK_OUT_OF_BOUNDS,playlistTrackOutOfBoundsErrorHandler);			_playlist.addEventListener(PlayrInternalEvent.PLAYLIST_STREAM_ERROR, playlistStreamErrorHandler);			_playlist.addEventListener(PlayrInternalEvent.PLAYLIST_INVALID_XML, invalidPlaylistXMLHandler);			_playlist.addEventListener(PlayrInternalEvent.TRACK_NOT_ADDED_TO_PLAYLIST, trackNotAddedToPlaylistErrorHandler);			_playlist.addEventListener(PlayrInternalEvent.TRACK_ADDED_TO_PLAYLIST, trackAddedToPlaylistHandler);			_playlist.addEventListener(PlayrInternalEvent.CURRENT_TRACK_TO_BE_REMOVED, currentTrackToBeRemovedHandler);			_trackProgressTimer.addEventListener(TimerEvent.TIMER, notifyTrackProgress);			state = PlayrStates.WAITING;		}				/**		 * Toggles between play and pause using the play() and pause() methods.		 */		public function togglePlayPause():void{			switch(playrState){				case PlayrStates.PLAYING:					pause();					break;				case PlayrStates.PAUSED:				case PlayrStates.STOPPED:				case PlayrStates.READY:					play();					break;			}		}						/**		 * Starts playing the loaded song or the playlist.<br />		 * If a playlist has been loaded, the singleTrack property will change to false.		 * If a single track has been loaded, the singleTrack property will change to true.		 */		public function play():void{			if(_playlist.getCurrentTrack() != null){				//trace("PlayrState: ",playrState);				if(playrState!=PlayrStates.PLAYING && playrState != PlayrStates.WAITING && playrState != PlayrStates.INIT){					if(_sound == null){    						var temp:Boolean = _autoPlay;						_autoPlay=false;						//trace(PlayrTrack(_playlist.getCurrentTrack()));						loadTrack(_playlist.getCurrentTrack().file, _playlist.getCurrentTrack());						//trace(_playlist.getCurrentTrack().file);						_autoPlay= temp;					}					_soundChannel = new SoundChannel();					_soundChannel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);					_soundChannel = _sound.play(_pauseTimer);					_trackProgressTimer.start();					volume = _volume;					panning = _panning;					scrobbled = false;					state = PlayrStates.PLAYING;				}			}			else{				state = PlayrStates.WAITING;			}		}		/**		 * Pauses the now playing track. <br />		 */		public function pause():void{			if(_soundChannel!=null){			_pauseTimer = _soundChannel.position;			_soundChannel.stop();			_trackProgressTimer.stop();			state = PlayrStates.PAUSED;			}		}		/**		 * Stops the now playing track. <br />		 */		public function stop():void{			if(_soundChannel != null){				_pauseTimer = 0;				_soundChannel.stop();				state = PlayrStates.STOPPED;				_trackProgressTimer.stop();			}			//recoilme			try { _sound.close(); } catch (err:Error) {}		}		/**		 * Advances the playlist to the next track. If the current track is the last track in the playlist, the playlist jumps to the first track of the playlist. <br />		 */		public function next():void{			if(_playlist.getCurrentTrack() != null)  {				stop();				_playlist.gotoNextTrack();				loadTrack(_playlist.getCurrentTrack().file, _playlist.getCurrentTrack());				dispatchEvent(new PlayrEvent(PlayrEvent.NEXT_TRACK));					play();			}		}		/**		 * Moves the playlist to the previous track. If the current track is the first track, the playlist jumps to the last track of the playlist. <br />		 */		public function previous():void{			stop();			_playlist.gotoPreviousTrack();			if(_playlist.getCurrentTrack() != null)  {				loadTrack(_playlist.getCurrentTrack().file, _playlist.getCurrentTrack());				dispatchEvent(new PlayrEvent(PlayrEvent.PREV_TRACK));					play();			}		}		/**		 * Jumps to the track of your choice in the playlist. <br />		 */		public function jumpToTrack(trackNumber:Number):void{			if(!singleTrack){					stop();					_playlist.gotoTrack(trackNumber);					loadTrack(_playlist.getCurrentTrack().file, _playlist.getCurrentTrack());					play();			}			else{				dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.NO_PLAYLIST_SELECTED));			}		}		/**		 * Scrobbles through the track. <br />		 */		public function scrobbleTo(target:Number):void{			if( _soundChannel != null){				_soundChannel.stop();				if(this.playrState != PlayrStates.STOPPED){					_soundChannel = _sound.play(target);					volume = _volume;					_soundChannel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);					if(this.playrState == PlayrStates.PAUSED){						pause();					}					var evt:PlayrEvent = new PlayrEvent(PlayrEvent.PLAYR_SCROBBLED);					evt.totalTime = totalTime;					evt.totalSeconds = totalSeconds;					evt.currentTime = currentTime;					evt.currentSeconds = currentSeconds;					dispatchEvent(evt);				}			}		}		/**		 * Load a XML playlist. Once loaded the internal playlist is populated with PlayrTrack objects. <br />		 */		public function loadPlaylist(playlistpath:String):void{			singleTrack = false;			_playlist.loadPlaylist(playlistpath);		}		/**		 * Loads a single track. There is no ID3 information loaded. The trackprogress/streamprogress events aren't accurate (The progress will be 0 at all times). This method is mostly designed to be used with anonymous loops. <br /> 		 * @param fileName The path to the mp3 file, you want to play.		 */		public function loadTrackFromURL(filename:String):void{			singleTrack = true;			loadTrack(filename);		}/**		 * Toggles the mute of the Playr instance. <br />		 */		public function toggleMute():void{			_mute = !_mute;			var st:SoundTransform;			if(_mute){				st = _soundChannel.soundTransform;				st.volume = 0;				_soundChannel.soundTransform = st;				dispatchEvent(new PlayrEvent(PlayrEvent.MUTED));			}			else{				st = _soundChannel.soundTransform;				st.volume = _volume;				_soundChannel.soundTransform = st;				dispatchEvent(new PlayrEvent(PlayrEvent.UNMUTED));			}		}		/**		 * Adds the play() method to a DisplayObject of your choice. <br />		 */		public function registerPlayButton(button:DisplayObject):void{			_playButton = button;			_playButton.addEventListener(MouseEvent.CLICK, handlePlayButtonClick);		}		/**		 * Adds the togglePlayPause() method to a DisplayObject of your choice. <br />		 */		public function registerTogglePlayPauseButton(button:DisplayObject):void{			_togglePlayPauseButton = button;			_togglePlayPauseButton.addEventListener(MouseEvent.CLICK, handleTogglePlayPauseButtonClick);		}		/**		 * Adds the pause() method to a DisplayObject of your choice. <br />		 */		public function registerPauseButton(button:DisplayObject):void{			_pauseButton = button;			_pauseButton.addEventListener(MouseEvent.CLICK, handlePauseButtonClick);		}		/**		 * Adds the stop() method to a DisplayObject of your choice. <br />		 */		public function registerStopButton(button:DisplayObject):void{			_stopButton = button;			_stopButton.addEventListener(MouseEvent.CLICK, handleStopButtonClick);		}		/**		 * Adds the next() method to a DisplayObject of your choice. <br />		 */		public function registerNextButton(button:DisplayObject):void{			_nextButton = button;			_nextButton.addEventListener(MouseEvent.CLICK, handleNextButtonClick);		}		/**		 * Adds the previous() method to a DisplayObject of your choice. <br />		 */		public function registerPreviousButton(button:DisplayObject):void{			_prevButton = button;			_prevButton.addEventListener(MouseEvent.CLICK, handlePreviousButtonClick);		}		/**		 * Adds the toggleMute() method to a DisplayObject of your choice. <br />		 */		public function registerMuteButton(button:DisplayObject):void{			_muteButton = button;			_muteButton.addEventListener(MouseEvent.CLICK, handleMuteButtonClick);		}		/**		 * Removes all eventlisteners from the Playr instance. <br />		 */		public function destroy():void{					if(_playButton != null){				_playButton.removeEventListener(MouseEvent.CLICK,handlePlayButtonClick);			}			if(_pauseButton != null){				_pauseButton.removeEventListener(MouseEvent.CLICK,handlePauseButtonClick);			}						if(_stopButton != null){				_stopButton.removeEventListener(MouseEvent.CLICK,handleStopButtonClick);			}			if(_muteButton != null){				_muteButton.removeEventListener(MouseEvent.CLICK,handleMuteButtonClick);			}			if(_nextButton != null){				_nextButton.removeEventListener(MouseEvent.CLICK,handleNextButtonClick);			}			if(_prevButton != null){				_prevButton.removeEventListener(MouseEvent.CLICK,handlePreviousButtonClick);			}			if(_togglePlayPauseButton != null){				_togglePlayPauseButton.removeEventListener(MouseEvent.CLICK,handleTogglePlayPauseButtonClick);			}		}		/**		 *	Fades the music out (from the current volume level to 0) 		 */		public function fadeOut(time:Number=2):void{		//	garbage.push(new Tween(this,'volume',null,this.volume,0,time,true));			fade(time,volume,0);		}		/**		 * Fades the music in (from 0 to a chosen target. If you don't give up a target volume, the fade will go from 0 to 1)		 */		public function fadeIn(time:Number=2,targetVolume:Number=1):void{			//garbage.push(new Tween(this,'volume',null,0,targetVolume,time,true));			volume=0;			fade(time,0,targetVolume);			//trace('fadeIn called');		}		/**		 * Fades the music from one volume to another over a given time frame.		 */		public function fade(time:Number,startVolume:Number,targetVolume:Number):void{			//garbage.push(new Tween(this,'volume',null,startVolume,targetVolume,time,true));			volume = startVolume;			fadeTime = time;			fadeBegin = startVolume;			fadeEnd = targetVolume;			fadeTimer.start();		}				/**		 * 		 * @param size (Number) seconds to load		 * 		 * Sets size of buffering in ms		 */		public function set buffer(size:Number):void{			bufferSize = size;		}								/********************************************************************************		*********************************************************************************		**********************									*************************		**********************									*************************		**********************		  Public properties			*************************		**********************									*************************		**********************									*************************		*********************************************************************************		********************************************************************************/ 				public function get playrState():String{			return _playrState;		}		private function set state(value:String):void{			_playrState = value;			var evt:PlayrEvent=new PlayrEvent(PlayrEvent.PLAYRSTATE_CHANGED);			evt.playrState = playrState;			dispatchEvent(evt);		}				/**		 * Returns the artist of the now playing track. This information is taken only from the playlist. 		 */		public function get artist():String{			return _playlist.getCurrentTrack().artist;		}		/**		 * Returns the artist of the now playing track. This information is taken only from the playlist. 		 */		public function get album():String{			return _playlist.getCurrentTrack().album;		}		/**		 * Returns the title of the now playing track. This information is taken only from the playlist. 		 */		public function get title():String{			return _playlist.getCurrentTrack().title;		}		/**		 * Returns the title name of the now playing track. This information is taken only from the playlist. 		 */		public function get titleName():String{			return _playlist.getCurrentTrack().titleName;		}		/**		 * Gets or sets the volume.  		 */		public function set volume(newVolume:Number):void{			/*if(newVolume>1){				_volume = 1;			}else */			if(newVolume<0){				_volume = 0;			} else {				_volume = newVolume;			}			if(!_mute){//if not muted, automatically change the volume				if(_soundChannel != null){					var st:SoundTransform = _soundChannel.soundTransform;					st.volume = _volume;					_soundChannel.soundTransform = st;				}			}			var evt:PlayrEvent=new PlayrEvent(PlayrEvent.VOLUME_SET);			evt.volume = _volume;			dispatchEvent(evt);	//should this still be fired, even when muted?		}		public function get volume():Number{			if(_mute){				return 0;			}			else {				return _volume;			}		}		/**		 * Gets or sets the autoplay property.  		 */		public function get autoPlay():Boolean{			return _autoPlay;		}		public function set autoPlay(value:Boolean):void{			_autoPlay = value;			if(_autoPlay){				play();			}		}		/**		 * Returns the interal playlist. This is an array consisting of all PlayrTracks. 		 */		public function get playlist():PlaylistManager{			return _playlist;		}		public function set playlist(list:PlaylistManager):void{			//trace('New playlist found. Setting up...');			stop();			_sound = null;			_soundChannel =null;			state = PlayrStates.LOADING_PLAYLIST;			_playlist = list;			_playlist.gotoFirstTrack();			state = PlayrStates.READY;			dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_UPDATED));						if(autoPlay){				play();			}		}		/**		 * Gets or sets the  shuffle property of the Playr instance. Shuffle in Playr 2.0 is smart. It remembers the previous tracks. Internally there is a secondary playlist. 		 */		public function get shuffle():Boolean{			return _playlist.shuffle;		}				public function set shuffle(value:Boolean):void{			var res:Boolean = _playlist.setShuffle(value); 			if(res && playrState != PlayrStates.INIT && playrState != PlayrStates.LOADING_PLAYLIST){				dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_UPDATED));			}			if(playrState != PlayrStates.PLAYING && res){				_playlist.gotoFirstTrack();			}		}						/**		 * Returns the total size of the now playing track. 		 */		public function get totalSize():int{			return _sound.bytesTotal;		}		/**		 * Returns the total number of seconds of the now playing track. This information is taken only from the playlist. 		 */		public function get totalSeconds():Number{			return _playlist.getCurrentTrack().totalSeconds;		}		/**		 * Returns the current amount of seconds of the track that have already been played as a number (for mathematical purposes).		 */		public function get currentSeconds():Number{			if(_soundChannel!=null){				return Math.round(Math.round(_soundChannel.position/1000));			}			else{				return 0;			}		}		/**		 * Returns the current amount of miliseconds of the track that have already been played as a number (for mathematical purposes).		 */		public function get currentMiliseconds():Number{			if(_soundChannel!=null){				return _soundChannel.position;			}			else{				return 0;			}		}		/**		 * Returns the current time of the track in a human readable format. Example: 2 minutes 16 seconds is '2:16'.		 */		public function get currentTime():String{			var pos:String="";			if(_soundChannel!=null){				var min:Number = (Math.round(_soundChannel.position/1000) - (Math.round(_soundChannel.position/1000)%60))/60;				var sec:Number = Math.ceil(_soundChannel.position/1000)%60;				pos = min + ':';					if(sec<10){						pos += "0";					}				pos += sec;			}			else{				pos = '0:00';			}			return pos;		}		/**		 * Returns the duration of the now playing track in a human readable format. Example: 2 minutes 16 seconds is '2:16'. This information is taken from the playlist.		 */		public function get totalTime():String{			return _playlist.getCurrentTrack().totalTime;		}		 		/**		 * Sets the panning (left and right speakers) of the music.		 */		 public function set panning(value:Number):void{		 	if(value>1){		 		_panning = 1;		 	}else if(value<-1){		 		_panning=-1		 	}else{		 		_panning = value;		 	}		 	if(_soundChannel !=null){			 	var st:SoundTransform = _soundChannel.soundTransform;			 	st.pan = _panning;			 	_soundChannel.soundTransform = st;			 }		 }		 public function get panning():Number{		 	return _panning;		 }		 public function get mute():Boolean{		 	return _mute;		 }		 public function set mute(value:Boolean):void{		 	if(_mute != value){		 		toggleMute();		 	}		 }		 		 		 		 		/********************************************************************************		*********************************************************************************		**********************									*************************		**********************									*************************		**********************		 Private handlers			*************************		**********************		 Private properties			*************************		**********************		 Internal functions			*************************		**********************									*************************		**********************									*************************		*********************************************************************************		********************************************************************************/ 				private function handleUpdate(e:TimerEvent):void{						var jump:Number = (fadeEnd - fadeBegin)/(fadeTime*10);// 10 is related to the 10 steps/second. 10 steps per second because of the 100ms timer tick. Might rewrite this one day...			//trace(jump);			if(Math.abs(jump) != jump){ //volume is lowering				//trace('lowering');				if(fadeEnd > volume + jump){					fadeTimer.stop();					volume=fadeEnd;					return;				}			}			else{//volume is rising				//trace('rising');				if(fadeEnd < volume + jump){					fadeTimer.stop();					volume=fadeEnd;					return;				}			}			volume += jump;				//trace(volume);		}		 		private function handleMuteButtonClick(e:MouseEvent):void{			toggleMute();		}		private function handlePlayButtonClick(e:MouseEvent):void{			play();		}		private function handlePauseButtonClick(e:MouseEvent):void{			pause();		}		private function handleStopButtonClick(e:MouseEvent):void{			stop();		}		private function handleNextButtonClick(e:MouseEvent):void{			next();		}		private function handlePreviousButtonClick(e:MouseEvent):void{			previous();		}		private function handleTogglePlayPauseButtonClick(e:MouseEvent):void{			togglePlayPause();		}		private function playlistManagerReady(e:PlayrInternalEvent):void{			state = PlayrStates.READY;			_playlist.gotoFirstTrack();			dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_LOADED));			if(_autoPlay){				play();			}		}		public function playTrack(track:PlayrTrack):void{			loadTrack(track.file,track);		}		private function loadTrack(filename:String,track:PlayrTrack=null):void{			//trace('Loading: ',filename,' -- Singletrack: ',singleTrack);			//var debug:PlayrInternalEvent = new PlayrInternalEvent(PlayrInternalEvent.DEBUG);			//debug.message = "here we go";			//dispatchEvent(debug);						var sp:PlayrEvent = new PlayrEvent(PlayrEvent.STREAM_PROGRESS);			sp.progress = 0;			var tp:PlayrEvent = new PlayrEvent(PlayrEvent.TRACK_PROGRESS);			tp.progress = 0;			var buffer:SoundLoaderContext = new SoundLoaderContext(bufferSize, false);			if(!singleTrack || track != null){				//playlist driven				if(track != null){					_playlist = new PlaylistManager();					_playlist.addTrack(track);					_playlist.gotoFirstTrack();					filename = track.file; //this is kinda unnecessary, but just in case...				}								//debug = new PlayrInternalEvent(PlayrInternalEvent.DEBUG);				//debug.message = "playlist driven";				//dispatchEvent(debug);				if(_sound != null){					_sound.removeEventListener(ProgressEvent.PROGRESS, showStreamProgress);					_sound.removeEventListener(IOErrorEvent.IO_ERROR,soundIOErrorHandler);				}				_sound = new Sound();				_sound.addEventListener(IOErrorEvent.IO_ERROR, ioErrorEventHandler);				if(track.streamRequest != null){					trace('load from request');					_sound.load(track.streamRequest,buffer);				}else{					_sound.load(new URLRequest(trackDirectory + filename),buffer);				}											dispatchEvent(sp);				dispatchEvent(tp);								_sound.addEventListener(ProgressEvent.PROGRESS, showStreamProgress);				_sound.addEventListener(IOErrorEvent.IO_ERROR,soundIOErrorHandler);				_sound.addEventListener(Event.COMPLETE, onTrackID3Info);								dispatchEvent(new PlayrEvent(PlayrEvent.SONGINFO));					//I still wonder if this is the right place to fire this event. Even though everything will be fine, even when an IOError occurs...				//if(playrState == PlayrStates.WAITING){					state = PlayrStates.READY;									//}			}			else{				//trace('ello');				//debug = new PlayrInternalEvent(PlayrInternalEvent.DEBUG);				//debug.message = "singletrack driven";				//dispatchEvent(debug);				var track:PlayrTrack = new PlayrTrack();				track.file = filename;								_playlist = new PlaylistManager();				_playlist.addTrack(track);				_playlist.gotoFirstTrack();								//debug = new PlayrInternalEvent(PlayrInternalEvent.DEBUG);				//debug.message = "Playlist ready";				//dispatchEvent(debug);									if(_sound != null){					_sound.removeEventListener(ProgressEvent.PROGRESS, showStreamProgress);					_sound.removeEventListener(IOErrorEvent.IO_ERROR,soundIOErrorHandler);				}								_sound = new Sound();				_sound.load(new URLRequest(trackDirectory + filename),buffer);											dispatchEvent(sp);				dispatchEvent(tp);								_sound.addEventListener(ProgressEvent.PROGRESS, showStreamProgress);				_sound.addEventListener(IOErrorEvent.IO_ERROR,soundIOErrorHandler);								_sound.addEventListener(Event.ID3, updateSingleTrackID3Info);				//if(playrState == PlayrStates.WAITING){					state = PlayrStates.READY;				//}			}			if(autoPlay){				play();			}		}				private function updateSingleTrackID3Info(e:Event):void{			_playlist.getCurrentTrack().artist = Sound(e.target).id3.artist;			_playlist.getCurrentTrack().album = Sound(e.target).id3.album;			_playlist.getCurrentTrack().title = Sound(e.target).id3.songName;			dispatchEvent(new PlayrEvent(PlayrEvent.SONGINFO));			}				private function onTrackID3Info(e:Event):void{			if (_playlist.getCurrentTrack().artist == "") 			  _playlist.getCurrentTrack().artist = Sound(e.target).id3.artist;			if (_playlist.getCurrentTrack().album == "" || _playlist.getCurrentTrack().album == "undefined"  || _playlist.getCurrentTrack().album == null) 				_playlist.getCurrentTrack().album = Sound(e.target).id3.album;			if (_playlist.getCurrentTrack().titleName == "") 				_playlist.getCurrentTrack().titleName = Sound(e.target).id3.songName;			if (_playlist.getCurrentTrack().totalSeconds == 0)				_playlist.getCurrentTrack().totalSeconds = Math.round(Sound(e.target).length/1000);			dispatchEvent(new PlayrEvent(PlayrEvent.ID3));			}				private function soundIOErrorHandler(e:IOErrorEvent):void{			stop();			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.SOUND_STREAM_ERROR));			next();					}		private function invalidPlaylistXMLHandler(e:PlayrInternalEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.PLAYLIST_INVALID_XML));		}		private function showStreamProgress(e:ProgressEvent):void{			var pe:PlayrEvent = new PlayrEvent(PlayrEvent.STREAM_PROGRESS);			pe.progress = e.bytesLoaded/e.bytesTotal;			dispatchEvent(pe);		}		private function notifyTrackProgress(e:TimerEvent):void{			if(_soundChannel != null && _playlist.getCurrentTrack() != null){				var pe:PlayrEvent = new PlayrEvent(PlayrEvent.TRACK_PROGRESS);				if(!singleTrack){					pe.progress = (_soundChannel.position/1000)/_playlist.getCurrentTrack().totalSeconds;					//trace(pe.progress);				}				dispatchEvent(pe);			}		}		private function playlistTrackOutOfBoundsErrorHandler(e:PlayrInternalEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.TRACK_OUT_OF_BOUNDS));		}		private function playlistStreamErrorHandler(e:PlayrInternalEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.PLAYLIST_STREAM_ERROR));		}		private function trackNotAddedToPlaylistErrorHandler(e:PlayrInternalEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.TRACK_NOT_ADDED_TO_PLAYLIST));		}		private function trackAddedToPlaylistHandler(e:PlayrInternalEvent):void{			if(_playlist.totalTracks ==1){				_playlist.gotoFirstTrack();				//if(playrState == PlayrStates.WAITING){					state = PlayrStates.READY;				//}				dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_LOADED));			}			else{				dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_UPDATED));			}			if(_playlist.toArray().length ==0){				_playlist.gotoFirstTrack();	//logica?			}			if(autoPlay){				play();			}		}		private function ioErrorEventHandler(e:IOErrorEvent):void{			dispatchEvent(new PlayrErrorEvent(PlayrErrorEvent.IO_ERROR));		}		private function currentTrackToBeRemovedHandler(e:PlayrInternalEvent):void{			stop();			_sound =null;			_soundChannel=null;			_playlist.gotoNextTrack();		}		private	function soundCompleteHandler(e:Event):void{			dispatchEvent(new PlayrEvent(PlayrEvent.TRACK_COMPLETE));						if(_playlist.totalTracks == _playlist.currentTrackNumber){ //end of playlist				if(repeat == PlayrRepeat.REPEAT_ALL){					dispatchEvent(new PlayrEvent(PlayrEvent.PLAYLIST_END_REACHED));					next();					play();				}				else if(repeat == PlayrRepeat.REPEAT_NONE){					stop();				}			}			else{				if(repeat == PlayrRepeat.REPEAT_SINGLE){	//end of track!					stop();					play();				}				else{					next();					play();				}			}		}	} }